# 前言

本文主要包含 Java 核心基础知识，主要根据以下部分进行节选，选择了个人认为在面试中最为核心的部分。



## 一、GC 垃圾回收机制

**判断对象是否为垃圾的算法：**

- **引用计数法：**通过判断对象的引用数量来决定对象是否可以被回收；每个对象实例都有一个计数器，被引用+1，完成引用-1；任何引用计数为0的实例可以被当作垃圾收集。

  **优点：**执行效率高，程序执行受影响较小。

  **缺点：**无法检测出循环引用的情况，导致内存泄漏：循环引用（父类子类相互引用）。

- **可达性分析算法：**从GC Root开始，判断对象引用链是否可达。

**垃圾回收算法：**

- **标记-清除算法：**

  标记：从根集合进行扫描，对存活对象进行标记。

  清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存。

  缺点：不需要移动，只需要清除不存活的对象，会产生大量不连续的内存碎片，会导致日后运行需要较大内存时无法找到足够的连续内存而不得不提前触发另一次垃圾回收工作。

- **复制算法：**

  21分为对象面和空闲面，对象主要是在对象面上创建，存活的对象被从对象面复制到空闲面，将对象面的所有对象内存清除。解决碎片化问题，顺序分配内存，简单高效，适用于对象存活率过低的从场景，主要应用于年轻代，年轻代中的回收基本只有10%的对象存活，但不适用于老年代。

- **标记-整理算法：**

  标记：从根集合进行扫描，对存活对象进行标记。

  清除：移动所有存活的对象，且按照内存地址依次排列，然后将末端地址以后的内存全部回收。

  是在标记-清除算法的基础上对对象进行了移动，通过可达性分析算法确定存活对象，再进行移动清除，避免了内存的不连续性，不用设置两块内存互换，适用于存活率高的场景。

- **分代收集算法：**

  垃圾回收算法的组合拳，按照对象生命周期的不同划分区域以采用不同的垃圾回收算法，提高JVM的回收效率；JDK8及其以后版本取消了永久代。

## 强引用、软引用、弱引用、虚引用：

![](./images/1`Z6XXE$0ZPX310M_OS9WJ9.png)

